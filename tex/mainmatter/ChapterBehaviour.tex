% Chapter 7

\chapter{Mechanized behavioural semantics} 
\label{chap:behaviour} 

\epigraph{\textit{â€œYet, ..."}}{Nuno Gaspar}



\minitoc


\lhead{Chapter 7. \emph{Mechanized behavioural semantics}} % This is for the header on each page - perhaps a shortened title

%----------------------------------------------------------------------------------------

	This chapter discusses the mechanization, in the Coq proof assistant, of a behavioural 
semantics based on the execution trace of synchronized labelled transition systems. Further, we show
how it can be used in the context of \ac{GCM} applications.

	Section \ref{sec:pLTS} presents the mechanization of \ac{LTS} and
their traces. We show how we can synchronize several \ac{LTS} in Section \ref{sec:pnet}.
Then, we exemplify its use in the context of \ac{GCM} applications in Section \ref{sec:gcmpnets}.
For last, Section \ref{sec:behaviourdiscussion} discusses the final remarks about this
mechanization.


\section{Labelled transition systems, and traces}
\label{sec:pLTS}

	
	\lstinputlisting[language=Coq, stepnumber=1, 
	                      caption={\textsf{lts\_state} datatype}, 
	                      %firstnumber=19,
	                      label=lst:ltsstate]{listings/chapter6/state.tex}	
	
	
	\noindent A \textsf{lts\_state} is identified by a natural number, and holds an internal memory that is a
	simple mapping between strings to naturals. For the sake of simplicity we directly use strings to denote variables,
	and constrain ourselves to natural number values.
	
	Next, let us now see the \textsf{action} datatype. Listing \ref{lst:action} illustrates its definition.
	
		\lstinputlisting[language=Coq, stepnumber=1, 
	                      caption={\textsf{action} datatype}, 
	                      %firstnumber=19,
	                      label=lst:action]{listings/chapter6/action.tex}	

	\noindent An \textsf{action} is composed by a \textsf{message}, and a set of \textsf{assignments}.
	As expected, the latter permits to specify the assignment of specific state variables to a \textsf{transition}.
	The former holds the label, its type of communication and a set of parameters. Listing \ref{lst:message}
	depicts its definition.
	
			\lstinputlisting[language=Coq, stepnumber=1, 
	                      caption={\textsf{message} datatype}, 
	                      %firstnumber=19,
	                      label=lst:message]{listings/chapter6/message.tex}	

	\noindent A message can either be \textit{reading} or \textit{emitting} (lines 2-3). Typically, these
	are used to receive and transmit values, respectively. Naturally, the allowed \textsf{parameters} are
	either values --- natural numbers --- or variables (lines 6-7).
	
	
	Finally, we can now see the \textsf{LTS} datatype as depicted by Listing \ref{lst:lts}.	
		
	\lstinputlisting[language=Coq, stepnumber=1, 
	                      caption={\textsf{LTS} datatype}, 
	                      %firstnumber=19,
	                      label=lst:lts]{listings/chapter6/LTS.tex}	

	Having defined the \textsf{LTS} datatype, we can now define \textsf{traces}. A trace is a sequence of actions 
	resulting from the sequence of \textsf{transitions} taken by the \textsf{LTS}. It can either be finite or
	infinite. A finite trace means that a \textit{sink} state was attained, thus the execution \textit{deadlocks}.
	Listing \ref{lst:ltstrace} defines a \textsf{LTS} trace.	
	
	
		\lstinputlisting[language=Coq, stepnumber=1, 
	                      caption={Trace definition for a \textsf{LTS}}, 
	                      %firstnumber=19,
	                      label=lst:ltstrace]{listings/chapter6/ltstrace.tex}	


	\noindent A \textsf{LTS\_Trace} is defined by a co-inductive predicate since we potentially deal
	with infinite sequences. The expression, \textsf{LTS\_Trace A q l}, means that \textsf{l} is a trace
	in the \textsf{LTS} object \textsf{A}, starting from the state \textsf{q}.   

		The \textsf{LTS\_Trace} predicate is composed by two constructors: \textsf{lts\_empty\_trace} (line 2)
	and \textsf{lts\_cons\_trace} (line 8).  The former simply expresses that, from any state, 
	all \textsf{actions} of the \textsf{LTS} yield no target state (lines 3-5). Indeed, the
	function 
	\textsf{lts\_target\_state : LTS $\rightarrow$ lts\_state $\rightarrow$ message $\rightarrow$ lts\_state}
	is responsible for computing the attained state from \textsf{q} with an \textsf{action} holding the message
	\textsf{m}. Thus, the constructor's conclusion is \textsf{LTS\_Trace A q LNil}, since the trace from \textsf{q}
	is empty.	The latter constructor however, demands the that we reach a state \textsf{q'} (line 11), and
	a trace from \textsf{q'} (line 12), in order to conclude \textsf{LTS\_Trace A q (LCons (Action m asgns) l)} (line 13).
	
		For the sake of clarity, Listing \ref{lst:ltstargetstate} depicts the \textsf{lts\_target\_state} function.	
	
		\lstinputlisting[language=Coq, stepnumber=1, 
	                      caption={\textsf{lts\_target\_state} function definition}, 
	                      %firstnumber=19,
	                      label=lst:ltstargetstate]{listings/chapter6/ltstargetstate.tex}			
	
	
	\noindent The function pattern matches the \textsf{message m} and checks whether its label
	is equal to \textsf{"-"}. If it is the case then it simply returns the current state \textsf{st} (line 19),
	otherwise it proceeds by calling the \textsf{lts\_get\_target\_state} function (line 20).
	The is due to the fact that we consider a \textsf{message} with a \textsf{"-"} label as
	a special case. As we shall see in Section \ref{sec:pnet}, this exception is related with the 
	way we deal with synchronization between \ac{LTS}.
	
	The \textsf{lts\_get\_target\_state} function starts by pattern matching on the \textsf{LTS}
	list of \textsf{transitions} (line 3),  returning no state if its empty (line 4). If it is not the 
	case (line 5), then we check if the \textsf{transition} at the head of the list possesses
	a source state that matches the parameter state \textsf{st}, and if the \textsf{message} contained
	in its \textsf{action} is equal to the parameter \textsf{message m} (line 6). Should that be the case,
	then it simply process the assignments associated with the taken \textsf{action} (line 9), and updates
	the target state memory accordingly (line 10). As expected, this the the purpose of the
	\textsf{process\_assignment : state\_mem $\rightarrow$ assignments $\rightarrow$ state\_mem} function, 
	and \textsf{-$>>$} notation, respectively. Otherwise it recurs on the tail of the list of 
	\textsf{transitions} (line 13).

	



\section{Synchronization of LTS, and traces}
\label{sec:pnet}

	In the previous Section we saw how to model a single \ac{LTS}. However, it is often the case
	that we want to be able to have several \ac{LTS} communicate with each other.	This is achieved
	by synchronizing their \textsf{actions}.
	
		First, let us formalize the notion of a synchronization vector. Listing \ref{lst:synchvectors}
	depicts its datatype.	
	
	\lstinputlisting[language=Coq, stepnumber=1, 
                      caption={\textsf{SynchronizationVector} datatype}, 
                      %firstnumber=19,
                      label=lst:synchvectors]{listings/chapter6/synchvectors.tex}		

	\noindent Basically, a synchronization vector is composed by a list of synchronization elements,
	and an output element (line 9). The former indicate the \textsf{actions} that need to be considered among
	the list of \ac{LTS} being synchronized. The latter stands for the resulting global action.  
	Both synchronization and output elements are represented by string values. For the sake of convenience
	we also permit synchronization elements to be defined through the \textsf{WildCard} constructor (line 2).
	Further we define a notation as depicted by Listing \ref{lst:synchvectorsnotation}.
	
	\lstinputlisting[language=Coq, stepnumber=1, 
                      caption={A convenient notation for \textsf{SynchronizationVector}}, 
                      %firstnumber=19,
                      label=lst:synchvectorsnotation]{listings/chapter6/synchvectorsnotation.tex}	
                      	
    \noindent Basically, it permits Coq to directly understand expressions such 
    as the following one: \textsf{$<<$ "x" , "y" , "-" , "z" $>>$ -> "XYZ"}.

	Let us now define a type for a communicating network of \ac{LTS}. We shall call this type \textsf{Net}.
	Its definition is depicted by Listing \ref{lst:net}.	

	\lstinputlisting[language=Coq, stepnumber=1, 
                     caption={\textsf{Net} datatype}, 
                     %firstnumber=19,
                     label=lst:net]{listings/chapter6/net.tex}	

	\noindent It is composed by two constructors: \textsf{mk\_SingletonNet} and \textsf{mk\_Net}.
	The former is used for simple models constituted with a single \ac{LTS}, while the latter
	permits to specify communicating \ac{LTS} by means of synchronization vectors.
	
	For this new structure we need a new notion of state. Listing \ref{lst:netstate} depicts the \textsf{pnet\_state}
	datatype.

	\lstinputlisting[language=Coq, stepnumber=1, 
                     caption={\textsf{net\_state} datatype}, 
                     %firstnumber=19,
                     label=lst:netstate]{listings/chapter6/netstate.tex}	

	\noindent Basically, both its constructors follow the same rationale: they keep track of the 
	involved \textsf{lst\_states}. 
	
	%indexed_membership
	%attainable
	
	Before proceeding to the definition of traces for	\textsf{Net}s, we need to consider
	how their transitions are performed. For this case, we need to consider the current
	\textsf{net\_state} and the activated synchronization vector. Moreover, each synchronization
	element may permit more than one \textsf{action} to occur. Thus, a function
	computing the target \textsf{net\_state}s must also return the resulting global action.
	Listing \ref{lst:nettargetstates} depicts such a function.
		
	\lstinputlisting[language=Coqfix, stepnumber=1, 
                     caption={\textsf{net\_target\_states} function definition}, 
                     %firstnumber=19,
                     label=lst:nettargetstates]{listings/chapter6/nettargetstates.tex}		
	
	
	\noindent The above function may seem complicated at first sight, and requires 
	a closer look. Basically, it starts by pattern matching on its \textsf{Net} parameter
	\textsf{net\_obj}, \textsf{net\_state} parameter \textsf{q}, and synchronization vector parameter
	\textsf{sv} (line 3). The function is supposed to be used with \textsf{Net} objects and \textsf{net\_state}
	modelling systems with \textsf{LTS} synchronization. Should that not be the case, it simply returns
	an empty list (line 17).
	
		
		Another useful function concerns the computation of the initial state of a \textsf{Net}.
	Listing \ref{lst:initnet} depicts its definition.
	
	\lstinputlisting[language=Coqfix, stepnumber=1, 
                     caption={\textsf{init\_net\_state} function}, 
                     %firstnumber=19,
                     label=lst:initnet]{listings/chapter6/initnet.tex}		
	
	\noindent Basically, the above function computes the initial state of a \textsf{Net}. This is achieved
	by pattern matching on the \textsf{Net} parameter \textsf{net\_obj} (line 2). If it is
	a \textsf{Net} with a single \textsf{LTS} object, than it simply returns the adequate \textsf{net\_state}
	constructor with the initial state of the \textsf{LTS} (line 3). Otherwise, it recursively
	gathers the initial state of each \textsf{LTS} objects composing \textsf{net\_obj} into
	the local variable \textsf{lq} (lines 5-9), and returns the adequate \textsf{net\_state}
	constructor with \textsf{lq} (line 10).
	
				
	
	
	
		
	
	
	
	Let us now define a predicate indicating whether a state can attain another state. Listing \ref{lst:attainable}
	depicts its formalization.
			
			\lstinputlisting[language=Coq, stepnumber=1, 
                     caption={\textsf{attainable} predicate definition}, 
                     %firstnumber=19,
                     label=lst:attainable]{listings/chapter6/attainable.tex}	
	
		
	\noindent 
	
	
	
		As expected, traces for \textsf{Net}s are slightly more involved than traces for \textsc{LTS}. 
	Listing \ref{lst:nettrace} formalizes the notion of trace for the \textsf{Net} datatype.
			

		\lstinputlisting[language=Coq, stepnumber=1, 
                     caption={Trace definition for \textsf{Net}}, 
                     %firstnumber=19,
                     label=lst:nettrace]{listings/chapter6/nettrace.tex}	
	
	\noindent It is composed by three constructors: \textsf{lts\_trace},
	\textsf{net\_empty\_trace} and \textsf{net\_lcons\_trace}.
		
	
	


\section{Modelling GCM internals}
\label{sec:gcmpnets}



\section{Discussion}
\label{sec:behaviourdiscussion}


	


\chapbreak

	In this chapter we presented the mechanization of a behavioural 
semantics based on the execution trace of synchronized labelled transition systems. Further, we
exemplified its use in the context of \ac{GCM} applications.
	
	In the following chapter we discuss the works related with this thesis.



